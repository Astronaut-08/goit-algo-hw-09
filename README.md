Для даного випадку найкращим алгоритмом для цієї задачі буде жадібний алгоритм.

Чому саме жадібний?
Тому що ми не маємо обмеження в монетах наприклад, в тому скільки монет може з собою понести відвідувач
звучить дивно, але якщо б відвідувач мав обмеження по вантажопідйомності монет но кращим вибором було б
вже динамічне програмування, тому що воно оптимальне. Завданням тобі стояло не віддати всю решту, а максимально
можливу.

Тому жабіному алгоритму не потрібно розраховувати оптимальний варіант, він бере від найбільшого і йде до меншого
доки не впреться, відповідно враховуючи нашу умову складність жадібного алгоритму складає О(n) тому що нам потрібно
обійти тільки кількість монет яка є n

Для динаміного програмування нам вже потрібно обрахувати оптимальний варіант, тому ми не просто йдемо від більшого
до меншого, ми розбиває нашу суму amount на кількість підсум, тобто якщо amount= 113, ми робимо таблицю з 113 випадків
тобто для суми 1, потім для суми 2, потім для суми 3 і тд. і при тому ще й для кожної монети! Кількість яких є n
тому складність в даній умові буде О(amount * n) що є більшим ніж просто О(n)

Але якщо б клієнт міг з собою винести тільки 3 монети замість 5, ми б шукали максимально найбільшу решту яку могли б йому дати
що і забезпечив нам би динамічний розв'язок, на відміну від жадібного
